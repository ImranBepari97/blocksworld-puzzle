
public class Node implements Comparable {
	
	/* A node class is used in the trees generated by the Algorithms class. It contains
	 * a board state, a value for the depth, and a Manhattan Distance used for the A* Heuristic.
	 */
	
	private State state;
	private int depth;
	private static char[] ALPHABET = "abcdefghijklmnopqrstuvwxyz".toCharArray();
	private int manDist;
	
	//Intial constructor, just makes a new fresh puzzle
	public Node(int n) {
		state = new State(n);
		this.depth = 1;
		manDist = calcManDistance();
	}
	
	public int getManDist() {
		return manDist;
	}

	/* New constructor for going down the tree. It takes the old State from before. It duplicates 
	* so that nothing breaks referencing up the tree. The depth can just incrememnt.
	*/
	public Node(State s, int depth) {
		state = s;
		this.depth = depth;
		manDist = calcManDistance();
	}

	//getters setters
	public State getState() {
		return state;
	}

	public void setState(State state) {
		this.state = state;
	}

	public int getDepth() {
		return depth;
	}

	public void setDepth(int depth) {
		this.depth = depth;
	}
	
	
	/* Calculates the Manhattan Distance
	 * Goes through the whole board and finds the letter blocks. It then uses that letter block
	 * relative to the ALPHABET array to calculate where the letter block should be in the array.
	 * It uses the distance as a cost, and sums up for every letter. 
	 */
	public int calcManDistance() {
		int manXDist = 0;
		int manYDist = 0;
		for (int y = 0; y < state.getSize(); y++) {
			for(int x = 0; x < state.getSize(); x++) {
				for (int c = 0; c < state.getSize(); c++) {
					if(state.getBoard()[y][x] == ALPHABET[c]) {
						manYDist += Math.abs(y - (c + 1)); 			
						manXDist += x;
					}
				}
			}
		}
		
		return manXDist + manYDist;
	}

	/*Comparable uses the Manhattan distances plus how deep the current node is to judge
	 * how good a Node is for getting to the solved state.
	 * (non-Javadoc)
	 * @see java.lang.Comparable#compareTo(java.lang.Object)
	 */
	@Override
	public int compareTo(Object node2) {
		return (this.manDist + depth) - (((Node) node2).manDist + ((Node) node2).depth);
	}
	
}
